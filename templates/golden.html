<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <title>Golden QA — generator i edytor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; font-family: system-ui, sans-serif; }
    body { margin: 0; padding: 24px; background: #f5f5f5; }
    .container { max-width: 1100px; margin: 0 auto; background: #fff; padding: 24px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
    h1, h2 { margin: 0 0 12px 0; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field label { font-weight: 600; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    input[type="text"], input[type="number"], select { padding: 10px; border-radius: 8px; border: 1px solid #ccc; font-size: 14px; width: 100%; }
    input[type="checkbox"] { transform: scale(1.1); }
    textarea { width: 100%; min-height: 56px; padding: 9px; border-radius: 8px; border: 1px solid #ccc; font-size: 13.5px; resize: vertical; font-family: ui-monospace, SFMono-Regular, Consolas, "Liberation Mono", Menlo, monospace; }
    button { padding: 10px 14px; border: none; border-radius: 8px; background: #0060df; color: #fff; font-weight: 600; cursor: pointer; }
    button.secondary { background: #6b7280; }
    button.success { background: #10b981; }
    button.warn { background: #d97706; }
    .note { color: #6b7280; font-size: 14px; }
    .status { margin-top: 10px; font-size: 14px; color: #374151; }
    .list { margin-top: 16px; display: flex; flex-direction: column; gap: 16px; }
    .card { border: 1px solid #e5e7eb; border-radius: 10px; padding: 14px; background: #fafafa; }
    .meta { font-size: 12px; color: #6b7280; margin-bottom: 8px; display: flex; gap: 8px; flex-wrap: wrap; }
    .meta .tag { background: #eef2ff; color: #3730a3; padding: 2px 8px; border-radius: 999px; }
    .actions { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .toolbar { display: flex; justify-content: space-between; align-items: center; margin-top: 16px; }
    .small { font-size: 12px; }
    .hidden { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Golden QA — generator i edytor</h1>
    <p class="note">Podaj parametry i uruchom generowanie bazy “golden”. Następnie poniżej pojawi się lista pytań i odpowiedzi do przeglądu/edycji.</p>

    <div class="grid">
      <div class="field">
        <label for="baseDir">Katalog korpusu (base_dir)</label>
        <input id="baseDir" type="text" value="data/Zarządzenia_JM_Rektora" placeholder="np. data/" />
      </div>
      <div class="field">
        <label for="glob">Wzorzec plików (glob)</label>
        <input id="glob" type="text" value="**/*" />
      </div>
      <div class="field">
        <label for="outDir">Katalog wyjściowy (out_dir)</label>
        <input id="outDir" type="text" value="data/golden" />
      </div>
      <div class="field">
        <label for="limitDocs">Limit dokumentów (opcjonalnie)</label>
        <input id="limitDocs" type="number" min="1" placeholder="np. 100" />
      </div>
      <div class="field">
        <label for="perDocQa">QA na dokument</label>
        <input id="perDocQa" type="number" min="1" value="2" />
      </div>
      <div class="field">
        <label for="targetQa">Docelowa liczba QA (opcjonalnie)</label>
        <input id="targetQa" type="number" min="1" placeholder="np. 30" />
      </div>
      <div class="field">
        <label for="seed">Seed</label>
        <input id="seed" type="number" placeholder="opcjonalny" />
      </div>
      <div class="field">
        <label>&nbsp;</label>
        <label class="row small"><input id="recursive" type="checkbox" checked /> Rekurencyjnie (recursive)</label>
      </div>
    </div>

    <div class="row" style="margin-top:12px;">
      <button id="runBtn">Uruchom generowanie</button>
      <button id="refreshBtn" class="secondary">Odśwież listę</button>
      <span id="status" class="status"></span>
    </div>

    <div class="toolbar">
      <h2>Lista pytań i odpowiedzi</h2>
      <span class="small" id="qaPath"></span>
    </div>
    <div id="list" class="list"></div>
  </div>

  <script>
    let currentOutDir = 'data/golden';

    function val(el) { return document.getElementById(el).value; }
    function bool(el) { return document.getElementById(el).checked; }
    function setText(el, text) { document.getElementById(el).textContent = text || ''; }
    function setStatus(text) { setText('status', text); }
    function el(id) { return document.getElementById(id); }

    async function generate() {
      setStatus('Generowanie…');
      const payload = {
        base_dir: val('baseDir'),
        glob: val('glob') || '**/*',
        recursive: bool('recursive'),
        out_dir: val('outDir') || 'data/golden',
        limit_docs: val('limitDocs') ? parseInt(val('limitDocs'), 10) : null,
        per_doc_qa: Math.max(1, parseInt(val('perDocQa') || '2', 10)),
        target_qa: val('targetQa') ? parseInt(val('targetQa'), 10) : null,
      };
      const seedStrGen = (val('seed') || '').trim();
      if (seedStrGen) {
        payload.seed = parseInt(seedStrGen, 10);
      }
      try {
        const res = await fetch('/golden/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data.detail || 'Błąd');
        }
        currentOutDir = payload.out_dir;
        setText('qaPath', data.qa_path || '');
        setStatus(`OK — dokumentów: ${data.documents}, QA: ${data.qa_items}, model: ${data.llm_model || 'n/d'}`);
        await loadList();
      } catch (err) {
        setStatus('Błąd: ' + err);
      }
    }

    async function loadList(highlightId = null, message = null) {
      const url = new URL(window.location.origin + '/golden/list');
      url.searchParams.set('out_dir', currentOutDir);
      setStatus('Wczytywanie listy…');
      try {
        const res = await fetch(url);
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data.detail || 'Błąd');
        }
        setText('qaPath', data.qa_path || '');
        renderList(data.items || []);
        setStatus(`Załadowano: ${data.items?.length || 0} pozycji`);
        if (highlightId && message) {
          const card = document.querySelector(`.card[data-id="${highlightId}"]`);
          if (card) {
            const s = card.querySelector('.status');
            if (s) {
              s.textContent = message;
            }
          }
        }
      } catch (err) {
        setStatus('Błąd: ' + err);
      }
    }

    function renderList(items) {
      const root = el('list');
      root.innerHTML = '';
      items.forEach((it) => {
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.id = it.id || '';
        const meta = document.createElement('div');
        meta.className = 'meta';
        const docTitle = (it.meta && it.meta.doc_title) || '';
        const docSymbol = (it.meta && it.meta.doc_symbol) || '';
        // Prefer a reasonably long title; fall back to symbol to avoid single-letter artifacts like "P"
        const doc = (docTitle && docTitle.trim().length >= 3) ? docTitle : (docSymbol || '');
        const path = (it.meta && it.meta.doc_path) || '';
        const tag = document.createElement('span'); tag.className = 'tag'; tag.textContent = it.id;
        meta.appendChild(tag);
        if (doc) {
          const tspan = document.createElement('span'); tspan.textContent = doc; meta.appendChild(tspan);
        }
        if (path) {
          const link = document.createElement('a');
          link.className = 'small';
          link.textContent = '[plik]';
          link.href = '/golden/file?path=' + encodeURIComponent(path);
          link.target = '_blank';
          link.rel = 'noopener';
          link.title = path;
          meta.appendChild(document.createTextNode(' '));
          meta.appendChild(link);
        }
        const q = document.createElement('textarea'); q.value = it.query || '';
        const a = document.createElement('textarea'); a.value = it.expected_answer || '';
        const actions = document.createElement('div'); actions.className = 'actions';
        const localStatus = document.createElement('span'); localStatus.className = 'small status';
        const save = document.createElement('button'); save.textContent = 'Zapisz';
        const regen = document.createElement('button'); regen.textContent = 'Zregeneruj'; regen.className = 'warn';
        const answerBtn = document.createElement('button'); answerBtn.textContent = 'Nowa odpowiedź'; answerBtn.className = 'success';
        save.onclick = async () => {
          save.disabled = true; regen.disabled = true;
          try {
            const payload = { out_dir: currentOutDir, id: it.id, query: q.value, expected_answer: a.value };
            const res = await fetch('/golden/update', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const data = await res.json();
            if (!res.ok) throw new Error(data.detail || 'Błąd');
            localStatus.textContent = 'Zapisano';
          } catch (err) {
            localStatus.textContent = 'Błąd zapisu: ' + err;
          } finally {
            save.disabled = false; regen.disabled = false;
          }
        };
        regen.onclick = async () => {
          save.disabled = true; regen.disabled = true;
          try {
            localStatus.textContent = 'Regeneracja…';
            const payload = {
              out_dir: currentOutDir,
              id: it.id,
              use_random_doc: true,
              base_dir: val('baseDir') || undefined,
              glob: val('glob') || '**/*',
              recursive: bool('recursive'),
              temperature: 0.7,
              ensure_different: true,
            };
            const seedStr = (val('seed') || '').trim();
            if (seedStr) {
              payload.seed = parseInt(seedStr, 10);
            }
            const res = await fetch('/golden/regenerate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const data = await res.json();
            if (!res.ok) throw new Error(data.detail || 'Błąd');
            q.value = data.query || q.value;
            a.value = data.expected_answer || a.value;
            // Odśwież listę, aby zaktualizować link do pliku i tytuł z nowego dokumentu
            await loadList(it.id, 'Zregenerowano');
          } catch (err) {
            localStatus.textContent = 'Błąd regeneracji: ' + err;
          } finally {
            save.disabled = false; regen.disabled = false;
          }
        };
        answerBtn.onclick = async () => {
          save.disabled = true; regen.disabled = true; answerBtn.disabled = true;
          try {
            localStatus.textContent = 'Generuję odpowiedź…';
            const payload = { out_dir: currentOutDir, id: it.id, temperature: 0.5 };
            const res = await fetch('/golden/answer', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            const data = await res.json();
            if (!res.ok) throw new Error(data.detail || 'Błąd');
            a.value = data.expected_answer || a.value;
            localStatus.textContent = 'Zaktualizowano odpowiedź';
          } catch (err) {
            localStatus.textContent = 'Błąd generowania odpowiedzi: ' + err;
          } finally {
            save.disabled = false; regen.disabled = false; answerBtn.disabled = false;
          }
        };
        actions.appendChild(save); actions.appendChild(regen); actions.appendChild(answerBtn); actions.appendChild(localStatus);
        card.appendChild(meta); card.appendChild(q); card.appendChild(a); card.appendChild(actions);
        root.appendChild(card);
      });
    }

    el('runBtn').addEventListener('click', generate);
    el('refreshBtn').addEventListener('click', loadList);
    // Init defaults (keep currentOutDir in sync)
    el('outDir').addEventListener('change', () => { currentOutDir = val('outDir') || 'data/golden'; });
  </script>
</body>
</html>
